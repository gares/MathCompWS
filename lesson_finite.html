<!DOCTYPE html>
<!--

README:
  - coqdoc_ids must contain all text-area with Coq code
  - init_pkgs may contain ['init, 'math-comp'] for algebra

  These variables are signalled by a "HERE" in a comment

-->
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="content-type" content="text/html;charset=utf-8" />

    <link rel="stylesheet" href="jscoq/external/bootstrap.min.css" />

    <title>Lesson 3 : Finite types</title>
  </head>


<body>
  <div id="ide-wrapper" class="toggled">
  <div id="code-wrapper">
  <div id="document">

<!-- lesson -->

<h1>Lesson 3 : Finite types</h1>
<div><textarea id='coq-ta-1'>
From mathcomp Require Import all_ssreflect.
</textarea></div>
<div>
<p>To play this document inside your browser use ALT-N and ALT-P.</p>
<hr/>

<h2>
 Objective of this course
</h2>
<p>  Understand the benefits and usage of finite types.</p>
<ul class="doclist">
  <li> formation principles
  </li>
  <li> A special case : ordinals</li>
  <li> New tools: finite functions and finite set theory</li>
  <li> Moving even closer to classical logic: choice and extensionality</li>
</ul>
<hr/>

<h2>Formation principle</h2>


<p>For a finite type, you can enumerate the elements
    the enumeration is a simple piece of data (based on sequences)
</p>
<ul class="doclist">
<li> The enumeration gives some computation principle</li>
<li> Elements of a finite type can be indexed</li>
</ul>
<hr/>

</div>
<div><textarea id='coq-ta-2'>
</textarea></div>
<div>
<h2>the simplest finite types: ordinal numbers</h2>

<p>initial segments of natural numbers</p>

<ul>
<li> Building blocks or yardsticks for other finite types </div>
<li> Usable as plain integers, thanks to coercions</li>
</ul>
<div><textarea id='coq-ta-3'>
About Ordinal.

Example two_in_I_4 := Ordinal (isT : 2 < 4).

Fail Example five_in_I_4 : Ordinal (isT : 5 < 4).

(* For ordinal types that contain at least one elements, there
  is an optimistic injection from nat. *)

Check inord.

(* Beware of hidden coercions when reading these statements. *)

Check inordK.

Check inord_val.

Example inord_val_3_4 : inord 2 = two_in_I_4 :> 'I_4.
Proof.
rewrite -[X in inord X]/(nat_of_ord two_in_I_4).
rewrite inord_val. by [].
Qed.
</textarea></div>
<div>
<h2> Finite type constructions.</h2>
<p>In the rest of this talk I will use the following pattern to
    verify that I have a finite type.</p>
<div><textarea id='coq-ta-4'>
Check [finType of 'I_4].

Fail Check [finType of nat].
</textarea></div>
<div>
<p> New finite types can be built from existing ones</p>
<ul>
  <li>ordinal types are the usual examples of basic finite types</li>
  <li>unit (with one element)</li>
  <li>bool (with two elements)</li>
  <li>cartesian product</li>
  <li>disjoint sum</li>
  <li>subtype</li>
  <li>function type</li>
</ul>
</div>
<div><textarea id='coq-ta-5'>

Check [finType of 'I_4 * 'I_3].

Definition twin_primes_lt100 :=
 {x : 'I_100 * 'I_100 | prime (fst x) &&
                      prime (snd x) && (snd x == (fst x) + 2 :> nat)}.

Check [finType of twin_primes_lt100].

Definition lesser_twin_100 :=
 {x : nat | prime x && prime (x + 2) && (x < 100)}.

Fail Check [finType of lesser_twin_100].

(* There is a solution to make lesser_twin_100 a finite type.
  It is not part of this lesson, but my attempt is available at the
  end of this file. *)

</textarea></div>
<div>
<h2>Building a finite type from scratch</h2>
<p>An example: building one's own finite type. Show that it
   is finite by exhibiting an injection into a finite type. </p>
</div>
<div><textarea id='coq-ta-6'>
Module LessonSandBox1.

Inductive card_point : predArgType := W | E | N | S.

Definition cp2o d : 'I_4 :=
  match d with
    W => inord 0 | E => inord 1 | N => inord 2 | S => inord 3
  end.

Definition o2cp (n : 'I_4) :=
  match val n with
    0 => Some W | 1 => Some E | 2 => Some N | 3 => Some S | _ => None
  end.

Lemma cp_can : pcancel cp2o o2cp.
Proof.
case.
rewrite /o2cp. rewrite /=. rewrite inordK. by []. by [].
by rewrite /o2cp /= inordK.
by rewrite /o2cp /= inordK.
by rewrite /o2cp /= inordK.
Qed.
</textarea></div>
<div>
<p>The lemma cp_can means that there is an injection from
  card_point into a known finite type.</p>
<p>Helper theorems a succession of added qualities:
<ul>
<li>equality is decidable <tt>eqType</tt></li>
<li>there is a canonical way to construct witness for every
  satisfiable predicate <tt>choiceType</tt></li>
<li>the elements can be enumerated <tt>countType</tt></li>
<li>the type card_point is finite.</li>
</ul>
<p>Each must be made into a canonical structure for later user</p>
</div>
<div><textarea id='coq-ta-7'>

Canonical cp_eqType := EqType card_point (PcanEqMixin cp_can).
Canonical card_point_choiceType :=
    ChoiceType card_point (PcanChoiceMixin cp_can).
Canonical cp_countType :=
    CountType card_point (PcanCountMixin cp_can).
Canonical card_point_finType := FinType card_point (PcanFinMixin cp_can).

Check [finType of card_point].

End LessonSandBox1.

</textarea></div>
<div>
<h2>Tools about finiteness</h2>
<p>More classical logic</p>
<ul class="doclist">
  <li> Quantifications of decidable predicates become decidable.</li>
  <li> Need to use special notations</li>
</ul>
 </div>
  <div><textarea id='coq-ta-8'>
  
Check [forall x : 'I_4, x < 2] && [exists x :'I_4, 4 < x].

Check [forall x : {x : 'I_100 | prime x}, 1 < x].

(* talk about connect, as predicate on graph. *)
</textarea></div>
<h2>Appendix: how to make lesser_twin_100 a finite type.</h2>
<p>Exhibit an injection from this type into a known finite type.</p>
<ul class="doclist">
  <li>Prove that it is an injection (find a left inverse)</li>
  <li>Use a theorem to build a canonical instance of Finite type</li>
</ul>
<div><textarea id="coq-ta-9">
Definition lesser_twin_100_in_ord (x : lesser_twin_100) : 'I_100.
case : x => x /andP [_ px]; exact (Ordinal px).
Defined.

Lemma build_andb (a b : bool) : a -> b -> a && b.
by move => -> ->. Qed.

Definition lesser_twin_from_ord (x : 'I_100) : option lesser_twin_100 :=
  match x with
  | Ordinal x px => 
     match Sumbool.sumbool_of_bool (prime x && prime (x + 2)) with
     | left h => Some (exist _ x (build_andb _ _ h px))
     | right h => None
     end
  end.

Lemma Pcan100 : pcancel lesser_twin_100_in_ord lesser_twin_from_ord.
Proof. case => x p /=.
case: (elimTF andP p) => p1 p2.
rewrite /lesser_twin_from_ord.
case: (Sumbool.sumbool_of_bool (prime x && prime (x + 2))).
  by move => a; congr Some; apply: val_inj => /=.
by rewrite p1.
Qed.

</textarea>
</

</div> <!-- /#document -->
</div> <!-- /#code-wrapper -->
</div> <!-- /#ide-wrapper  -->

<script src="./jscoq/js/jscoq-loader.js" type="text/javascript"></script>
<script type="text/javascript">


   var coqdoc_ids = ['coq-ta-1',  'coq-ta-2',  'coq-ta-3',  'coq-ta-4', 
                    'coq-ta-5',  'coq-ta-6',  'coq-ta-7', 'coq-ta-8',
                    'coq-ta-9'];
    var coq;

    loadJsCoq('./jscoq/')
              .then(loadJs("./jscoq/external/CodeMirror/addon/runmode/runmode"))
              .then(loadJs("./jscoq/external/CodeMirror/addon/runmode/colorize"))
              .then( function () {
                  var coqInline = document.getElementsByClassName("inline-coq");
                  CodeMirror.colorize(coqInline); })
              .then( function () {
                  coq = new CoqManager (coqdoc_ids,
                                       {
			base_path: './jscoq/',
		        init_pkgs: ['init']    // HERE
		}
                  );
              });
  </script>
</body>
</html>
